<div align="center">
<h1> BeamZ </h1>

[![PyPI version](https://badge.fury.io/py/beamz.svg)](https://badge.fury.io/py/beamz)
[![Last Commit](https://img.shields.io/github/last-commit/QuentinWach/beamz)](https://github.com/QuentinWach/beamz/commits/main)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Create inverse designs for your photonic devices with ease and efficiency.

[Homepage]() •
[Documentation](#documentation) •
[Examples](#examples) •
[Development](#development) •
[Cite](#cite)
</div>

Added dispersion and material library.

v0.1.0:           (Open alpha.)    


v0.0.5: May 10,   (Closed alpha.) 3D Design, simulation, optimization.
v0.0.4: May 4,    (Closed alpha.) Added GPU backend (Jax or PyTorch).
v0.0.3: April 27, (Closed alpha.) 2D Shape optimization.
v0.0.2: April 20, (Closed alpha.) 2D Adjoint method and topology optimization using FDTD.
v0.0.1: April 13, (Closed alpha.) 2D FDTD package proof of concept on CPU (Numpy).


Future releases:
+ FDFD solver (with CPU and GPU backend).
+ BPM solver (with CPU and GPU backend).

```bash
pip install beamz
```

The purpose it not merely to create a free tool for simulation, design, and optimization for photonic devices
but to create the environment needed to develop advanced AIs that can create complex photonic devices
that outperform any traditional devices generated by man or through non-learning-based optimiziation techniques.

+ **COMPLETE FREE 3D SiN PHOTONICS PDK** (Maybe?)
   - +50 building blocks
   - component characterizations
   - designed to be efficient and robust
   - including the design code so you can tune it to your needs

## Features
+ **Native integration** with GDSFactory, Nazca, and more.
+ **FDFD and FDTD** solvers! Most inverse design optimizitions are much faster using FDFD.
+ **Native GPU-acceleration** (but CPU multi-threading option).
+ **Topology optimization** using the adjoint method & auto-differentiation.
+ **Simple API** for quick .gds import and design of structures.
+ **Material Library** including dispersive and non-dispersive material models.

### Examples
There is no easier, faster way to setup and run a FDTD simulation than with BeamZ! Look at this simple example!
```python
from beamz import *
import numpy as np

WL = 1.55*µm
TIME = 40*WL/LIGHT_SPEED
T = np.linspace(0, TIME, int(TIME/(0.015*WL/LIGHT_SPEED)))
design = Design(width=6*µm, height=6*µm, material=Material(2.1, 1.0, 0.0))
design.add(Rectangle(position=(0,1*µm), width=6*µm, height=0.4*µm, material=Material(6.25, 1.0, 0.0)))
design.add(Ring(position=(3*µm, 3.35*µm), inner_radius=1.5*µm, outer_radius=1.9*µm, material=Material(6.25, 1.0, 0.0)))
signal = ramped_cosine(T, amplitude=1.0, frequency=LIGHT_SPEED/WL, phase=0, ramp_duration=TIME/2, t_max=TIME)
design.add(ModeSource(design=design, start=(1.5*µm, 0.8*µm), end=(1.5*µm, 1.6*µm), wavelength=WL, signal=signal))
FDTD(design=design, time=T, mesh="regular", resolution=WL/40).run()
```
In effectively 9 lines of code, you set up the structure of waveguide and ring resonator, defined a complex signal that ramps up and down, rasterized and simulated the structure!


### Design
You can design a quick layout easily using beamz's design module! Just create a design area
and start adding like rectangles, rings, bends, circles, or any arbitrary polygon to it.
Select the materials you want and use the `show()` method to view the design you've created.
```python
design = Design(width=6*µm, height=6*µm, material=SiO2)
design.add(Rectangle(position=(0,1*µm), width=6*µm, height=0.4*µm, material=SiN))
design.add(Ring(position=(3*µm, 3.5*µm), inner_radius=1.5*µm, outer_radius=1.9*µm, material=SiN))
design.add(CircularBend(position=(3*µm, 3.5*µm), inner_radius=0.9*µm, outer_radius=1.3*µm, angle=90, rotation=-200, material=SiN))
design.scatter(Circle(position=(3*µm, 3*µm), radius=0.05*µm, material=SiN), n=1000)
design.show()
```
I don't think there is any easier way to create a layout than this.

Alternatively, you can use GDSFactory as well!
```python

```

Or just directly import a gds file!
```python

```

You can export the design as a .gds file as well as .gltf file, as a simple .png image or as a config for beamz to reuse in future simulations.

TODO:
+ Add pins so we can easily chain structures.
+ Add parameterization:
   + Methods: Return and change parameters of an object.
   + Generate more polygon points around the sides of the polygon.
   + Calculate the normal vectors of each polygon point.
   + Calculate the curvature at every polygon point.
   + Randomly shift the polygon points e.g. to create roughness or defects.

TODO: https://pypi.org/project/shapely/ Use shapely and introduce boolean operations and operations to simplify complex shapes etc.!


TODO: Note that, the more structures you add, the slower the rasterization will be. We can speed this up massively by only considering structures close to the point we want to sample. 

TODO: Interactive 3D view of design and data using PyVista!

TODO: Add and benchmark different kinds of sub-pixel smoothing in the rasterization: https://math.mit.edu/~stevenj/papers/FarjadpourRo06-SPIE.pdf
+ If you just need quick anti-aliasing, use effective permittivity averaging.
+ If you need higher accuracy, try contour integration.
+ If you're dealing with complex curvatures, polynomial fitting or Level Set Methods could be beneficial.
https://math.mit.edu/~stevenj/papers/OskooiKo09.pdf

## Examples
Coming soon...


## Documentation
Coming soon...

We prefer not to clutter the code with lengthy explanations but to keep the docstrings concise, covering the essentials like purpose, parameters, and return values. We expand on the details, usage examples, and tutorials within your dedicated docs/ folder.


## Development

_BeamZ_ is currently in early developement and not feature complete or optimized for speed. That means any contributions you make now will have a major impact!

To get started, install _BeamZ_ for developement:
```bash
git clone https://github.com/QuentinWach/beamz.git
cd beamz
pip install -e .
```

### Priorities

1. _BeamZ_ optimized for the GPU for speed but also provides a multi-threaded CPU backend so you can **run it on any device** and expect it to be **fast** while keeping it **local** and your **IP secure**!

2. _BeamZ_ is a **community project**. That means making it as easy to use and as easy to contribute to this project are priorities rather than optimizing the software for speed or adding a long list of features few people will ever use and just overcomplicate developement. An extensive documentation, examples, and community building are on top of the list but keeping the code compact is more important than spamming comments for documentation purposes all around it.



### Contributing Through Git
You can see open issues and feauture requests on GitHub. To contribute towards the developement follow the genral steps below:

1. Fork the repository on GitHub.
2. Clone your fork locally and install the dependencies:
   ```bash
   git clone https://github.com/QuentinWach/beamz.git
   cd beamz
   pip install -e .
   ```
3. Create a new branch for your feature:
   ```bash
   git checkout -b feature/your-feature-name
   ```
4. Make your changes and commit them:
   ```bash
   git add .
   git commit -m "Description of your changes"
   ```
5. Push your changes to your fork:
   ```bash
   git push origin feature/your-feature-name
   ```
6. Create a Pull Request (PR) on GitHub from your branch.

In general, making commits can be easily done in the VSCode GUI but we recommend actually using git commands in the terminal for pushing changes and creating new branches. 


### Test-driven Development (TDD)

We are developing _BeamZ_ with a test-first approach. For any new feature, you first write tests that will check if the feature is working, then you write the feature, running the tests to see when it is indeed working:

1. **Write a Failing Test**
   - Create a new test file in the `tests/` directory.
   - Write a test that describes the expected behavior of your feature.
   - The test should fail initially since the feature doesn't exist yet.
   ```python
   def test_new_feature():
       # Arrange
       input_data = ...
       expected_output = ...
       
       # Act
       result = your_new_feature(input_data)
       
       # Assert
       assert result == expected_output
   ```

2. **Write the Feature**
   - Implement the feature to make the test pass.
   - Keep the implementation simple and focused on passing the test.
   - Don't add functionality that isn't tested.

3. **Refactor**
   - Clean up the code while keeping all tests passing.
   - Improve readability and maintainability.
   - Remove any duplication.

4. **Repeat**
   - Add more test cases to cover edge cases.
   - Enhance the feature based on new requirements.
   - Keep the cycle going until the feature is complete.

#### Running Tests

```bash
# Run all tests
pytest

# Run a specific test file
pytest tests/test_your_feature.py

# Run tests with coverage report
pytest --cov=beamz tests/
```

#### Best Practices

- Write tests that are independent of each other.
- Use meaningful test names that describe the expected behavior.
- Follow the Arrange-Act-Assert pattern in your tests.
- Keep tests simple and focused on one behavior.
- Use fixtures for common setup code.
- Mock external dependencies when appropriate.


## Cite

If you use BeamZ in your research, please cite it using the following BibTeX entry:

```bibtex
@software{beamz2025,
  author = {Wach, Quentin},
  title = {BeamZ: A Fast and Efficient Tool for Photonic Device Inverse Design},
  year = {2025},
  publisher = {GitHub},
  url = {https://github.com/QuentinWach/beamz},
  version = {0.0.1}
}
```

You can also cite the specific version you used by including the DOI from Zenodo (coming soon).

https://nbviewer.org/github/fancompute/workshop-invdesign/blob/master/02_Invdes_intro.ipynb

https://nbviewer.org/github/fancompute/workshop-invdesign/blob/master/01_First_simulation.ipynb

